
System Name (example):
Realtime Notification Service (Simplified)

Purpose

A backend service that:
delivers real-time in-app notifications using SignalR
supports user-specific and category-based notifications
allows users to subscribe/unsubscribe to categories
supports scheduled notifications
persists notifications so users can fetch them later

📌 No SMS, no email, no push providers


Core Features:

🔹 Notification Types

1. User Notification:
sent to a specific user
no subscription needed

2. Category Notification
sent to all users subscribed to a category



🔹 Subscriptions:

Users can:
subscribe to categories
unsubscribe from categories

When connected via SignalR:
user joins category SignalR groups automatically


Scheduled Notifications

Notifications can be:
sent immediately
scheduled for a future time

⚠️ Simplified scheduling:
background service
database polling
no distributed scheduler


🔹 Real-Time Delivery
Online users → SignalR
Offline users → stored in DB


🔹 Notification History
Fetch notifications (paginated)
Mark as read
Unread count

🔹 Authentication
JWT authentication
SignalR secured using JWT

======================================================================

Make a foreign key navigation to ApplicationUser only if your data must always load together with the
user and you control query loading carefully (monoliths, internal business logic).
Store just the UserId without a FK if the system should be decoupled, scalable, or shared across 
services (e.g., notifications, preferences) — validate existence via API or service.
Rule of thumb: FK → tight coupling and integrity; UserId only → flexibility and horizontal 
scalability.In notification systems, most tables keep UserId only, 
while other domains (Employee, Orders) can have real FK relations.


=================================================================================

⚠️ Issues & Improvements (important ones)
1️⃣ Logout should be IDEMPOTENT

Right now:

if(existingToken == null || existingToken.IsExpired)
    return Failure Unauthorized


👉 This causes problems:

User clicks logout twice

Cookie already deleted

Token already revoked

You return 401 Unauthorized

🚫 That’s bad UX and not REST-friendly


---> Fix some Auth Issues

---------------------------------------------------

Application
 ├─ Abstractions
 │   ├─ Persistence
 │   │   └─ INotificationRepository
 │   ├─ Messaging
 │   │   └─ IEmailSender
 │   └─ Services
 │       └─ INotificationService
 |      Securiry
 |		└─ IAuthenticationService
 │
 ├─ Services              ✅ IMPLEMENTATIONS LIVE HERE
 │   └─ NotificationService
 │
 ├─ Dtos
 │   ├─ Requests
 │   └─ Responses
 │
 ├─ Validation
 │   └─ CreateNotificationValidator
 │
 ├─ Common
 │   ├─ Errors
 │   ├─ Messages
 │   └─ Result
 │
 └─ DependencyInjection
     └─ ApplicationDI


=================================================================================   

What is BodyBuilder?
BodyBuilder is a MailKit helper class that helps you construct the body of an email.



| Type       | Purpose                                                     |
| ---------- | ----------------------------------------------------------- |
| `TextBody` | Fallback for old clients, screen readers, security scanners |
| `HtmlBody` | Rich email (styles, buttons, links, tables)                 |

TextBody:
Hello Omar,
Your order was confirmed.

HtmlBody:
<h1>Hello Omar</h1>
<p>Your <b>order</b> was confirmed.</p>

Why not always HTML?

Good question. Reasons:
Some systems prefer plain text (logs, internal emails)
Some security filters distrust HTML-only emails
Plain text emails are simpler and safer